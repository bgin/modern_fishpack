!
!     file comf.f
!
!
!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!     *                                                               *
!     *                  copyright (c) 2005 by UCAR                   *
!     *                                                               *
!     *       University Corporation for Atmospheric Research         *
!     *                                                               *
!     *                      all rights reserved                      *
!     *                                                               *
!     *                    FISHPACK90  version 1.1                    *
!     *                                                               *
!     *                 A Package of Fortran 77 and 90                *
!     *                                                               *
!     *                Subroutines and Example Programs               *
!     *                                                               *
!     *               for Modeling Geophysical Processes              *
!     *                                                               *
!     *                             by                                *
!     *                                                               *
!     *        John Adams, Paul Swarztrauber and Roland Sweet         *
!     *                                                               *
!     *                             of                                *
!     *                                                               *
!     *         the National Center for Atmospheric Research          *
!     *                                                               *
!     *                Boulder, Colorado  (80307)  U.S.A.             *
!     *                                                               *
!     *                   which is sponsored by                       *
!     *                                                               *
!     *              the National Science Foundation                  *
!     *                                                               *
!     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!
!
! PACKAGE COMF           THE ENTRIES IN THIS PACKAGE ARE LOWLEVEL
!                        ENTRIES, SUPPORTING FISHPACK ENTRIES BLKTRI
!                        AND CBLKTRI. THAT IS, THESE ROUTINES ARE
!                        NOT CALLED DIRECTLY BY USERS, BUT RATHER
!                        BY ENTRIES WITHIN BLKTRI AND CBLKTRI.
!                        DESCRIPTION OF ENTRIES EPMACH AND PI_MACH
!                        FOLLOW BELOW.
!
! LATEST REVISION        JUNE 2004
!
! SPECIAL CONDITIONS     NONE
!
! I/O                    NONE
!
! PRECISION              SINGLE
!
! REQUIRED LIBRARY       NONE
! FILES
!
! LANGUAGE               FORTRAN 90
! ********************************************************************
!
! FUNCTION EPMACH (DUM)
!
! PURPOSE                TO COMPUTE AN APPROXIMATE MACHINE ACCURACY
!                        EPSILON ACCORDING TO THE FOLLOWING DEFINITION:
!                        EPSILON IS THE SMALLEST NUMBER SUCH THAT
!                        (1.+EPSILON).GT.1.)
!
! USAGE                  EPS = EPMACH (DUM)
!
! ARGUMENTS
! ON INPUT               DUM
!                          DUMMY VALUE
!
! ARGUMENTS
! ON OUTPUT              NONE
!
! HISTORY                THE ORIGINAL VERSION, WRITTEN WHEN THE
!                        BLKTRI PACKAGE WAS CONVERTED FROM THE
!                        CDC 7600 TO RUN ON THE CRAY-1, CALCULATED
!                        MACHINE ACCURACY BY SUCCESSIVE DIVISIONS
!                        BY 10.  USE OF THIS CONSTANT CAUSED BLKTRI
!                        TO COMPUTE SOLUTIONS ON THE CRAY-1 WITH FOUR
!                        FEWER PLACES OF ACCURACY THAN THE VERSION
!                        ON THE 7600.  IT WAS FOUND THAT COMPUTING
!                        MACHINE ACCURACY BY SUCCESSIVE DIVISIONS
!                        OF 2 PRODUCED A MACHINE ACCURACY 29% LESS
!                        THAN THE VALUE GENERATED BY SUCCESSIVE
!                        DIVISIONS BY 10, AND THAT USE OF THIS
!                        MACHINE CONSTANT IN THE BLKTRI PACKAGE
!                        RECOVERED THE ACCURACY THAT APPEARED TO
!                        BE LOST ON CONVERSION.
!
! ALGORITHM              COMPUTES MACHINE ACCURACY BY SUCCESSIVE
!                        DIVISIONS OF TWO.
!
! PORTABILITY            THIS CODE WILL EXECUTE ON MACHINES OTHER
!                        THAN THE CRAY1, BUT THE RETURNED VALUE MAY
!                        BE UNSATISFACTORY.  SEE HISTORY ABOVE.
! ********************************************************************
!
! FUNCTION PI_MACH (DUM)
!
! PURPOSE                TO SUPPLY THE VALUE OF THE CONSTANT PI
!                        CORRECT TO MACHINE PRECISION WHERE
!                        PI=3.141592653589793238462643383279502884197
!                             1693993751058209749446
!
! USAGE                  PI = PI_MACH (DUM)
!
! ARGUMENTS
! ON INPUT               DUM
!                          DUMMY VALUE
!
! ARGUMENTS
! ON OUTPUT              NONE
!
! ALGORITHM              THE VALUE OF PI IS SET TO 4.*ATAN(1.0)
!
! PORTABILITY            THIS ENTRY IS PORTABLE, BUT USERS SHOULD
!                        CHECK TO SEE WHETHER GREATER ACCURACY IS
!                        REQUIRED.
!
!***********************************************************************
module module_comf

    use, intrinsic :: iso_fortran_env, only: &
        ip => INT32, &
        wp => REAL64

    ! Explicit typing only
    implicit none

    ! Everything is private unless stated otherwise
    private
    public :: epmach
    public :: strwrd
    public :: ppsgf
    public :: ppspf
    public :: psgf
    public :: get_machine_precision_pi

contains
    !
    !*****************************************************************************************
    !
    function EPMACH( dum ) result( return_value )
        !-----------------------------------------------
        ! Dictionary: calling arguments
        !-----------------------------------------------
        real (wp) :: dum
        real (wp) :: return_value
        !-----------------------------------------------
        ! Dictionary: local variables
        !-----------------------------------------------
        real (wp), save :: alll
        real (wp)       :: eps, v
        common /value/  v
        !-----------------------------------------------

        eps = 1.0_wp
        eps = eps/2

        call STRWRD(eps + 1.0_wp)

        do while(v - 1.0_wp > 0.0_wp)
            eps = eps/2
            call STRWRD(eps + 1.0_wp)
        end do

        return_value = 100.0_wp * eps

    end function EPMACH
    !
    !*****************************************************************************************
    !
    subroutine STRWRD(x)
        !-----------------------------------------------
        ! Dictionary: calling arguments
        !-----------------------------------------------
        real (wp), intent(in) :: x
        !-----------------------------------------------
        ! TODO: Replace common block!!!
        !-----------------------------------------------
        common /value/ v
        real (wp)  v
        !-----------------------------------------------
        ! Dictionary: local variables
        !-----------------------------------------------
        real (wp), save :: alll
        !-----------------------------------------------

        v = x

    end subroutine STRWRD
    !
    !*****************************************************************************************
    !
    function PPSGF(x, iz, c, a, bh) result( return_value )
        !-----------------------------------------------
        ! Dictionary: calling arguments
        !-----------------------------------------------
        integer (ip), intent(in) :: iz
        real (wp), intent(in) :: x
        real (wp) :: c(*)
        real (wp) :: a(*)
        real (wp), intent(in) :: bh(*)
        real (wp) :: return_value
        !-----------------------------------------------
        ! Dictionary: local variables
        !-----------------------------------------------
        integer (ip)    :: j
        real (wp), save :: alll
        real (wp)       :: summation
        !-----------------------------------------------

        summation = 0.0_wp

        do j = 1, iz
            summation = summation - 1.0_wp/(x - bh(j))**2
        end do

        return_value = summation

    end function PPSGF
    !
    !*****************************************************************************************
    !
    function PPSPF(x, iz, c, a, bh) result( return_value )
        !-----------------------------------------------
        ! Dictionary: calling arguments
        !-----------------------------------------------
        integer (ip), intent(in)  :: iz
        real (wp),    intent(in)  :: x
        real (wp)                 :: c(*)
        real (wp)                 :: a(*)
        real (wp),     intent(in) :: bh(*)
        real (wp)                 :: return_value
        !-----------------------------------------------
        ! Dictionary: local variables
        !-----------------------------------------------
        integer (wp)     :: j
        real (wp), save  :: alll
        real (wp)        :: summation
        !-----------------------------------------------

        summation = 0.0_wp

        do j = 1, iz
            summation = summation + 1.0_wp/(x - bh(j))
        end do

        return_value = summation

    end function PPSPF
    !
    !*****************************************************************************************
    !
    function PSGF(x, iz, c, a, bh) result( return_value )
        !-----------------------------------------------
        ! Dictionary: calling arguments
        !-----------------------------------------------
        integer (ip), intent(in) :: iz
        real (wp), intent(in) :: x
        real (wp), intent(in) :: c(*)
        real (wp), intent(in) :: a(*)
        real (wp), intent(in)   :: bh(*)
        real (wp)               :: return_value
        !-----------------------------------------------
        ! Dictionary: local variables
        !-----------------------------------------------
        integer (ip)    :: j
        real (wp), save :: alll
        real (wp)       :: fsg, hsg, dd
        !-----------------------------------------------

        fsg = 1.0_wp
        hsg = 1.0_wp

        do j = 1, iz
            dd = 1.0_wp/(x - bh(j))
            fsg = fsg*a(j)*dd
            hsg = hsg*c(j)*dd
        end do

        if (mod(iz, 2) == 0) then
            return_value = 1.0_wp - fsg - hsg
            return
        end if

        return_value = 1.0_wp + fsg + hsg

    end function PSGF
    !
    !*****************************************************************************************
    !
    pure function get_machine_precision_pi(x) result (return_value)
        !-----------------------------------------------
        ! Dictionary: calling arguments
        !-----------------------------------------------
        real (wp), intent (in)  :: x
        real (wp)               :: return_value
        !-----------------------------------------------

        return_value = acos( -1.0_wp )

    end function get_machine_precision_pi
    !
    !*****************************************************************************************
    !
end module module_comf
!
! REVISION HISTORY---
!
! SEPTEMBER 1973    VERSION 1
! APRIL     1976    VERSION 2
! JANUARY   1978    VERSION 3
! DECEMBER  1979    VERSION 3.1
! FEBRUARY  1985    DOCUMENTATION UPGRADE
! NOVEMBER  1988    VERSION 3.2, FORTRAN 77 CHANGES
! June      2004    Version 5.0, Fortran 90 changes
! September 2015    Renamed PIMACH -> PI_MACH to avoid conflicts with SPHEREPACK 3.2
! February  2016    Extensive refactoring
!-----------------------------------------------------------------------
